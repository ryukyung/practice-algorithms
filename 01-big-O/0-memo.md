### 간단하게 정리하기

1. 알고리즘의 성능을 분석하기 위해서 빅오표기법(Big O)을 사용한다.
2. 정확한 시간에 따른 구분이나 하드웨어의 영향이 아닌 전체적인 추세를 중요하게 생각하며, 빅오표기법을 통해 알 수 있다.
3. [빅오(BIG O) 시간/공간 복잡도 퀴즈 보러가기](./4-question.md)

### Big O

- 여러가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법
- [코드 실행 시간 비교 코드 보러가기](./1-checkCodeTime.js)

### 시간 복잡도

- 입력이 커질수록 알고리즘의 실행 속도가 어떻게 바귀는지 분석한다.
- 예시: [예시 코드 보러가기](./2-timeComplexity.js)
  1. `timeComplexity1`
  - 이 함수의 연산은 항상 3번이다. (`n+1`, `n * (n+1)`, `(n * (n+1)) / 2`)
  - n의 값이 2, 1000 상관없이 늘 연산은 총 3번이므로 시간복잡도는 `O(1)`이라고 할 수 있다.
  2. `timeComplexity2`
  - 이 함수의 연산은 n의 값에 따라 달라진다.
  - n의 값이 2라면 2, 1000이라면 1000으로 n의 값에 따라 변하기 때문에 시간복잡도는 `O(n)`이라고 할 수 있다.
  3. `timeComplexity3`
  - 이 함수의 연산은 `timeComplexity2`와 같게 n의 값에 따라 달라진다.
  - for 루프가 중첩되지 않았기 때문에 `O(n) + O(n)`으로 `O(n+n)`이라고 표현할 수 있지만, 단순화하면 `O(n)`이 된다.
  4. `timeComplexity4`
  - 이 함수의 연산은 n의 값에 따라 n^2로 달라진다.
  - n의 값이 2라면 4, 3이라면 9, 4라면 16으로 n의 값에 따라 n^2로 변하기 때문에 시간복잡도를 `O(n)`이라고 하기 어렵다.
  - for 루프가 중첩되었기 때문에 `O(n) * O(n)`으로 `O(n*n)`이라고 표현할 수 있지만, 단순화하면 `O(n^2)`이 된다.

### 공간 복잡도

- 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간
- booleans, undefined, null은 자바스크립트에서 모두 불변 공간이다.
- 입력의 크기와 상관없이 숫자가 1이든 1000이든 모두 불변 공간이다.
- string은 O(n) [길이가 50자인 공간은 길이가 1자인 공간보다 50배 더 많은 공간을 차지한다.]
- array, object는 대부분 O(n) [n은 배열의 길이, 키의 개수, ...]
- 예시: [예시 코드 보러가기](./3-spaceComplexity.js)
  1.  `spaceComplexity1`
      - 이 함수에서는 `total`, `i`가 숫자형이다.
      - `total` 변수는 받아오는 값에 따라서 달라지지만 숫자는 숫자일 뿐이므로 공간복잡도는 `O(1)`이 된다.
  2.  `spaceComplexity2`
      - 이 함수에서는 배열을 사용한다.
      - 받아오는 값에 따라서 `newArr`의 크기가 변하므로 공간복잡도는 `O(n)`이 된다.
